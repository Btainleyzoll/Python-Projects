from vulnerability_scanner import connect_port
import socket
import re
def find_banner(ip, open_ports, debug = False):
    #list of common keywords in the service banners
    banner_keywords = [ 
    # SSH
    "OpenSSH", "Dropbear", "libssh", "SSH",
    # HTTP / Web Servers
    "Apache", "nginx", "Microsoft-IIS", "LiteSpeed", "Caddy", "Gunicorn", "Jetty",
    # FTP
    "vsftpd", "ProFTPD", "Pure-FTPd", "FileZilla", "FTP",
    # SMTP / Mail Servers
    "Postfix", "Exim", "Sendmail", "Microsoft ESMTP", "Courier",
    # POP3 / IMAP
    "Dovecot", "Courier-IMAP", "Microsoft Exchange", "UW-IMAP",
    # Database Servers
    "MySQL", "PostgreSQL", "MongoDB", "Oracle", "Microsoft SQL Server", "MSSQL",
    # Other Common Services
    "Redis", "Memcached", "Tomcat", "ElasticSearch", "RabbitMQ"
]
    port_info = {}  #This will hold the results {port: {service, version}}
    msg = b"\r\n"   #a small probe message for certain services who need a probe to respond
    
    #Loops through every open port given user specifications
    for port in open_ports:
        service_name = None
        service_version = None
        
        #Tries to map the known service for the port
        try:
            service_name = socket.getservbyport(port, "tcp")
        except OSError:
            service_name = None #if its a unknown or custom service that getservbyport() cannot get
            
        sock = None
        try:
            #Tries to connect to port
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2) #Used to avoid hanging
            sock.connect((ip, port))
            
            try: 
                # sends a probe in case the port needs it to trigger a banner
                sock.send(msg) 
                banner = sock.recv(2048) #reads the banner
                serviceVersion = str(banner.decode(errors = "ignore"))
                
                if debug:
                    print(f"[DEBUG] Port {port} raw banner: {serviceVersion}" )
                
                #Checks to see if any known service keyword exists in the banner
                for check in banner_keywords:
                    if check in serviceVersion:
                        service_name = check #matched service
                        #Used regex to extract version number after service name
                        m = re.search(rf"{check}[ /_-]?([0-9][0-9A-Za-z\.\-_]*)", serviceVersion)
                        if m:
                            service_version = m.group(1)
                        break #stops after first match to avoid errors or leaking
  
            except Exception:
                #If banner grab fails, log it, (only for debugging)
                if debug:
                    print(f"[DEBUG] Port {port} banner read failure.")

        except (socket.timeout, ConnectionRefusedError): # in case the socket cannot connect
            service_name = None
            service_version = None
        finally:
            if sock:
                sock.close() #Always close socket
        
        #Saves result for the port        
        port_info[port] = {"service": service_name, 
                           "version": service_version
                           }
    return port_info
                
            