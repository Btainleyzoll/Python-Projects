import json
def load_nvd():
    '''
    Loads teh National Vulnerability Database (NVD) JSON file
    Returns the entire dataset as a python dictionary
    '''
    with open('nvdcve-2.0-modified.json', 'r', encoding='utf-8') as f:
        nvd_data = json.load(f)
        return nvd_data
    
def extract_cpes(cve):
    '''
    Extracts the CPE(Common Platform Enumeration) string from a given CVE entry
    This only returns the CPes that are considered vulnerable
    '''
    cpes = []
    configs = cve.get("cve", {}).get("configurations", [])
    for config in configs:
        for node in config.get("nodes", []):
            for cpe in node.get("cpeMatch", []):
                if cpe.get("vulnerable"): #only holds the CPEs that are vulnerable
                    cpes.append(cpe["criteria"])

    return cpes

def parse_cpe(cpes):
    '''
    Parses the raw CPE string into dictionaries which contain the following:
    part (a = application, o = operating system, h = hardware)
    vendor (ex. apache or microsoft)
    product (ex. windows or http_server)
    version(ex 11 or 2.4.49)
    
    EXAMPLE
    Input: "cpe:2.3:a:phoenixcontact-software:multiprog:5.0:*:*:*:*:*:*:*"
    Output: {"part": "a", "vendor": "phoenixcontact-software", "product": "multiprog", "version": "5.0"}
    
    '''
    parsed = []
    for x in cpes:
        cutup = x.split(":")
        if len(cutup) >= 6: #confirms CPE is in a valid format
            
            parsed.append({"part":cutup[2], 
                           "vendor":cutup[3], 
                           "product":cutup[4], 
                           "version":cutup[5]
                           })
    return parsed    
        
        
      
def matcher(port_info, parsed_cpe):
    """
    Compares the detected services from the banner grabbing with the parsed CPE entries.
    This returns a list of the CPEs that match from the detected services
    Rules for match:
    CPE product must exist int the detected service name
    CPE version must either be '*', which means any, '-', which means unspecified, '', which means blank
    or must match to the detected service version
    """
    matches = []
    
    service_name = (port_info.get("service") or "").lower()
    service_version = (port_info.get("version") or "").lower()
    
    for cpe in parsed_cpe:
        if not service_name:
            continue
        if cpe["product"].lower() in service_name and (cpe["version"].lower() in ["*", "-", ""] or cpe["version"].lower() == service_version):
            matches.append(cpe)
    return matches

            
def find_vulnerability(port_info, nvd_data):
    '''
    Given the service name and version and NVD dataset,
    it finds and returns a list of any matching vulnerabilities.
    Each vulnerability have a cve_id which is its identifier i.e. CVE-2021-41773 and
    a description, which is a readable summary of what the vulnerability is.
    '''
    vulnerabilities = []
    for vul in nvd_data.get("vulnerabilities", []):
        # gets the CVE ID and description in english
        cve_id = vul.get("cve", {}).get("id", "Unknown")
        descriptions = vul.get("cve", {}).get("descriptions", [])
        desc = next((d["value"] for d in descriptions if d["lang"] == "en"), "")
        
        #Match detected service compared against the CPEs in this CVE
        cpes = extract_cpes(vul)
        parsed_cpe = parse_cpe(cpes)
        matches = matcher(port_info, parsed_cpe)
        
        if matches:
            vulnerabilities.append({"cve_id": cve_id, "description": desc})
    
    #in case nothing matches, puts in a placeholder         
    if not vulnerabilities:
        vulnerabilities.append({"cve_id": "None", "description": "No banner or no vulnerability"})
    
    return vulnerabilities