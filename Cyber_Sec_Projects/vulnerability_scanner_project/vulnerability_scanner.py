'''
This is my Vulnerability scanner 


'''
import socket
import concurrent.futures
import threading
from tqdm import tqdm

lock = threading.Lock()
open_ports = [22]

def single_scan_port(ip, portnum):
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(.5)
    
    try:
        sock.connect((ip, portnum))
        with lock:
            open_ports.append(portnum)
            
    except socket.timeout:
        pass
    
    except ConnectionRefusedError:
        pass
    
    finally:
        sock.close()
        if not open_ports:
            print("No open ports were found given the specifications.")

def big_scan(ip, portnum):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(.5)
    try:
        sock.connect((ip, portnum))
        with lock:
            open_ports.append(portnum)
    except socket.timeout:
        pass
    except ConnectionRefusedError:
        pass
    finally:
        sock.close()
    
         

def connect_port(ip, ports ):
    common = [21, 22, 23, 25, 53, 80, 110, 143, 443, 3389, 8080]
    
    if ports == "all":
        port_range = range(0, 65535)
        print("Trying to connect to all ports")
        executor = concurrent.futures.ThreadPoolExecutor(max_workers = 1000)
        futures = [executor.submit(big_scan, ip, portnum) for portnum in port_range]
        for _ in tqdm(concurrent.futures.as_completed(futures), total = len(futures)):
            pass
        executor.shutdown(wait = True)
        if not open_ports:
            print("No open ports were found given the specifications.")
        else:
            return ip, open_ports
        
    elif ports == "common":
        print("Trying to connect to common ports ")
        executor = concurrent.futures.ThreadPoolExecutor(max_workers = 50)
        for portnum in common:
            executor.submit(single_scan_port, ip, portnum)
        executor.shutdown(wait = True) 
        return ip, open_ports
        
    else:
        executor = concurrent.futures.ThreadPoolExecutor(max_workers = 100)
        
        if len(ports) == 1:
            executor.submit(single_scan_port, ip, ports[0])
            return ip, open_ports
            
        else:
            port_range = ports
            futures = [executor.submit(big_scan, ip, portnum) for portnum in port_range]
            for _ in tqdm(concurrent.futures.as_completed(futures), total = len(futures)):
                pass
                
            if not open_ports:
                print("No open ports were found given the specifications.")
            else:
                return ip, open_ports
               
                
        executor.shutdown(wait = True)
            